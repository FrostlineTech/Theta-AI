[
  {
    "question": "How do I migrate a JavaScript project to TypeScript?",
    "answer": "Migrating a JavaScript project to TypeScript involves several steps and can be done incrementally:\n\n1. **Set up TypeScript in your project**:\n```bash\n# Install TypeScript\nnpm install --save-dev typescript\n\n# Initialize a TypeScript configuration file\nnpx tsc --init\n```\n\n2. **Configure tsconfig.json** for a smooth transition:\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"es2016\",\n    \"module\": \"commonjs\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": false,        // Start with false for easier migration\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"allowJs\": true,       // Allow JavaScript files\n    \"checkJs\": false,      // Don't type-check JS files initially\n    \"noImplicitAny\": false // Allow implicit any initially\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\"]\n}\n```\n\n3. **Rename .js files to .ts or .tsx** (for React):\n   - Start with simpler files or isolated modules\n   - Fix any immediate type errors before moving to the next file\n\n4. **Add type declarations** gradually:\n```typescript\n// From JavaScript:\nfunction calculateTotal(items, tax) {\n  return items.reduce((sum, item) => sum + item.price, 0) * (1 + tax);\n}\n\n// To TypeScript:\ninterface Item {\n  name: string;\n  price: number;\n}\n\nfunction calculateTotal(items: Item[], tax: number): number {\n  return items.reduce((sum, item) => sum + item.price, 0) * (1 + tax);\n}\n```\n\n5. **Use declaration files** for third-party libraries:\n```bash\n# Example for installing React types\nnpm install --save-dev @types/react @types/react-dom\n```\n\n6. **Create custom type declarations** for libraries without TypeScript support:\n```typescript\n// declarations.d.ts\ndeclare module 'untyped-module' {\n  export function doSomething(input: string): number;\n  export const VERSION: string;\n}\n```\n\n7. **Gradually increase strictness** in tsconfig.json as your codebase stabilizes:\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true\n  }\n}\n```\n\n8. **Update your build process** to compile TypeScript:\n   - For webpack: `npm install --save-dev ts-loader`\n   - For Rollup: `npm install --save-dev @rollup/plugin-typescript`\n   - For Babel: `npm install --save-dev @babel/preset-typescript`\n\nThis incremental approach lets you migrate at your own pace while continuously having a working application.",
    "domain": "programming"
  },
  {
    "question": "What are the main differences between JavaScript and TypeScript?",
    "answer": "JavaScript and TypeScript differ in several key areas:\n\n1. **Type System**\n   - JavaScript: Dynamically typed, types are determined at runtime\n   - TypeScript: Statically typed, types are checked at compile time\n\n   ```javascript\n   // JavaScript\n   let name = \"John\";\n   name = 42; // Works fine in JavaScript\n   ```\n\n   ```typescript\n   // TypeScript\n   let name: string = \"John\";\n   name = 42; // Error: Type 'number' is not assignable to type 'string'\n   ```\n\n2. **Interfaces and Type Definitions**\n   - JavaScript: No built-in way to define interfaces\n   - TypeScript: Robust interface system\n\n   ```typescript\n   interface User {\n     id: number;\n     name: string;\n     email: string;\n     age?: number; // Optional property\n   }\n\n   function createUser(user: User): User {\n     return user;\n   }\n   ```\n\n3. **Class Features**\n   - JavaScript: Basic class syntax since ES2015\n   - TypeScript: Enhanced with access modifiers, parameter properties, abstract classes\n\n   ```typescript\n   class Person {\n     private id: number;\n     protected history: string[];\n     public name: string;\n\n     constructor(id: number, name: string) {\n       this.id = id;\n       this.name = name;\n       this.history = [];\n     }\n   }\n   ```\n\n4. **Enums**\n   - JavaScript: No native enum support\n   - TypeScript: Full enum support\n\n   ```typescript\n   enum Direction {\n     North,\n     East,\n     South,\n     West\n   }\n   let direction: Direction = Direction.North;\n   ```\n\n5. **Function Signatures**\n   - JavaScript: No parameter type checking\n   - TypeScript: Detailed function signatures\n\n   ```typescript\n   function calculate(x: number, y: number, operation: 'add' | 'subtract'): number {\n     return operation === 'add' ? x + y : x - y;\n   }\n   ```\n\n6. **Generics**\n   - JavaScript: No generics\n   - TypeScript: Full generic support\n\n   ```typescript\n   function getFirstItem<T>(arr: T[]): T | undefined {\n     return arr.length > 0 ? arr[0] : undefined;\n   }\n\n   const number = getFirstItem<number>([1, 2, 3]); // Type: number | undefined\n   const string = getFirstItem<string>(['a', 'b']); // Type: string | undefined\n   ```\n\n7. **Module Management**\n   - JavaScript: Multiple standards (CommonJS, ES modules)\n   - TypeScript: Unified module system with enhanced import/export typing\n\n8. **Tooling Support**\n   - JavaScript: Limited IDE support for code analysis\n   - TypeScript: Rich IDE support with intelligent code completion, refactoring tools, and error detection\n\n9. **Compilation Step**\n   - JavaScript: Directly executed by browsers/Node.js\n   - TypeScript: Requires compilation to JavaScript before execution\n\n10. **Backward Compatibility**\n    - TypeScript is a superset of JavaScript, meaning all valid JavaScript code is also valid TypeScript code (with `\"strict\": false` in tsconfig.json)",
    "domain": "programming"
  },
  {
    "question": "How do I create TypeScript declaration files for JavaScript libraries?",
    "answer": "Creating TypeScript declaration files (.d.ts) for JavaScript libraries involves defining the types for the library's API. Here's a step-by-step guide:\n\n1. **Basic Declaration File Structure**:\n\n```typescript\n// example-library.d.ts\ndeclare module 'example-library' {\n  // Export types, interfaces, functions, classes, etc.\n  export function someFunction(param: string): number;\n  export const VERSION: string;\n  \n  export interface SomeOptions {\n    delay?: number;\n    retries: number;\n  }\n  \n  export class SomeClass {\n    constructor(options: SomeOptions);\n    doSomething(input: string): Promise<void>;\n    getData(): Record<string, unknown>;\n  }\n  \n  // Default export\n  export default function(): SomeClass;\n}\n```\n\n2. **Global Library Declaration** (for libraries attached to the window object):\n\n```typescript\n// global-library.d.ts\ndeclare namespace GlobalLibrary {\n  function initialize(options?: InitOptions): void;\n  function getData(id: string): any;\n  \n  interface InitOptions {\n    apiKey: string;\n    timeout?: number;\n  }\n}\n\ninterface Window {\n  GlobalLibrary: typeof GlobalLibrary;\n}\n```\n\n3. **Module Augmentation** (adding to existing modules):\n\n```typescript\n// express-extension.d.ts\nimport * as express from 'express';\n\ndeclare module 'express' {\n  interface Request {\n    user?: {\n      id: string;\n      username: string;\n      roles: string[];\n    };\n  }\n}\n```\n\n4. **Complex Example with Generics**:\n\n```typescript\n// data-library.d.ts\ndeclare module 'data-library' {\n  export interface DataOptions<T> {\n    initialValue?: T;\n    validator?: (value: T) => boolean;\n  }\n  \n  export class DataStore<T> {\n    constructor(options?: DataOptions<T>);\n    get(): T;\n    set(value: T): void;\n    subscribe(callback: (newValue: T) => void): () => void;\n  }\n  \n  export function createStore<T>(initialValue: T): DataStore<T>;\n  \n  export namespace utils {\n    function deepCopy<T>(obj: T): T;\n    function isEqual<T>(a: T, b: T): boolean;\n  }\n}\n```\n\n5. **Adding JSDoc Comments** for better documentation:\n\n```typescript\ndeclare module 'api-client' {\n  /**\n   * Client for making API requests\n   * @param baseUrl - The base URL for API requests\n   * @param options - Configuration options\n   */\n  export class ApiClient {\n    constructor(baseUrl: string, options?: ClientOptions);\n    \n    /**\n     * Makes a GET request to the specified endpoint\n     * @param endpoint - API endpoint path\n     * @param params - Query parameters\n     * @returns Promise resolving to the response data\n     */\n    get<T>(endpoint: string, params?: Record<string, string>): Promise<T>;\n  }\n  \n  /**\n   * Configuration options for the API client\n   */\n  export interface ClientOptions {\n    /**\n     * Authentication token\n     */\n    token?: string;\n    \n    /**\n     * Request timeout in milliseconds\n     * @default 5000\n     */\n    timeout?: number;\n  }\n}\n```\n\n6. **Publishing Declaration Files** with your package:\n   - Add a `types` or `typings` field in package.json pointing to your declaration file\n   - Example: `\"types\": \"./dist/index.d.ts\"`\n\n7. **Organizing Declaration Files** for larger libraries:\n   - Use a directory structure that mirrors your source code\n   - Create an index.d.ts file that re-exports from other files\n\n```typescript\n// index.d.ts\ndeclare module 'my-library' {\n  export * from './types/core';\n  export * from './types/utils';\n  export * from './types/models';\n}\n```",
    "domain": "programming"
  },
  {
    "question": "How does TypeScript's type inference work?",
    "answer": "TypeScript's type inference system automatically determines types without explicit annotations. Here's a comprehensive explanation:\n\n1. **Basic Variable Inference**\n\n```typescript\n// Type: string\nlet name = \"Alice\";\n\n// Type: number\nlet age = 30;\n\n// Type: boolean\nlet isActive = true;\n\n// Type: string[]\nlet fruits = [\"apple\", \"banana\", \"orange\"];\n\n// Type: { name: string; age: number }\nlet person = {\n  name: \"Bob\",\n  age: 25\n};\n```\n\n2. **Function Return Type Inference**\n\n```typescript\n// Return type inferred as number\nfunction add(a: number, b: number) {\n  return a + b;\n}\n\n// Return type inferred as string | number\nfunction getValue(key: string) {\n  if (key === \"count\") {\n    return 42;\n  }\n  return key;\n}\n```\n\n3. **Contextual Typing** (inferring from context)\n\n```typescript\n// Parameter 'event' is inferred as MouseEvent\ndocument.addEventListener(\"click\", (event) => {\n  console.log(event.clientX, event.clientY);\n});\n\n// Parameter 'item' is inferred as string\n[\"a\", \"b\", \"c\"].map((item) => item.toUpperCase());\n```\n\n4. **Type Widening and Narrowing**\n\n```typescript\n// Type widened to string\nlet message = \"hello\"; // Type: string, not literal \"hello\"\n\n// Using const preserves literal type\nconst greeting = \"hello\"; // Type: \"hello\" (literal string)\n\n// Type narrowing with control flow analysis\nfunction example(value: string | number) {\n  if (typeof value === \"string\") {\n    // Here, TypeScript knows value is a string\n    return value.toUpperCase();\n  } else {\n    // Here, TypeScript knows value is a number\n    return value.toFixed(2);\n  }\n}\n```\n\n5. **Union Types and Type Guards**\n\n```typescript\nfunction process(value: string | number) {\n  // Type guard\n  if (typeof value === \"string\") {\n    // In this block, value is inferred as string\n    return value.toLowerCase();\n  } else {\n    // In this block, value is inferred as number\n    return value.toFixed(2);\n  }\n}\n```\n\n6. **Inferred Generic Types**\n\n```typescript\n// Generic type parameter T is inferred as number\nfunction identity<T>(value: T): T {\n  return value;\n}\nlet result = identity(42); // result: number\n\n// Array.map with inferred types\nconst numbers = [1, 2, 3];\nconst doubled = numbers.map(n => n * 2); // doubled: number[]\n```\n\n7. **Destructuring and Inference**\n\n```typescript\nconst person = {\n  name: \"Alice\",\n  age: 30,\n  address: {\n    street: \"123 Main St\",\n    city: \"Anytown\"\n  }\n};\n\n// Types inferred through destructuring\nconst { name, age } = person; // name: string, age: number\nconst { address: { city } } = person; // city: string\n```\n\n8. **Best Practices with Inference**\n\n```typescript\n// Let TypeScript infer simple types\nlet count = 0; // Good: Inferred as number\n\n// Provide explicit types for complex objects or empty containers\nlet userData: {\n  id: number;\n  preferences: { theme: string; notifications: boolean };\n} = {\n  id: 1,\n  preferences: { theme: \"dark\", notifications: true }\n};\n\nconst emptyArray: string[] = []; // Good: Explicit type for empty array\n\n// Return types are often good to annotate, even when they could be inferred\nfunction fetchData(): Promise<UserData[]> {\n  // Implementation\n  return Promise.resolve([]);\n}\n```\n\nUnderstanding type inference helps write clean TypeScript code by avoiding redundant annotations while maintaining type safety.",
    "domain": "programming"
  },
  {
    "question": "What are the best practices for using TypeScript with React?",
    "answer": "Here are the best practices for using TypeScript with React:\n\n1. **Defining Component Props and State**\n\n```typescript\n// Using interfaces for props\ninterface ButtonProps {\n  text: string;\n  onClick: () => void;\n  disabled?: boolean;\n  variant?: 'primary' | 'secondary' | 'danger';\n}\n\n// Function component with typed props\nconst Button: React.FC<ButtonProps> = ({ \n  text, \n  onClick, \n  disabled = false, \n  variant = 'primary' \n}) => {\n  return (\n    <button \n      className={`btn btn-${variant}`}\n      onClick={onClick}\n      disabled={disabled}\n    >\n      {text}\n    </button>\n  );\n};\n```\n\n2. **Using Generic Components**\n\n```typescript\ninterface SelectProps<T> {\n  items: T[];\n  selectedItem: T | null;\n  onChange: (item: T) => void;\n  renderItem: (item: T) => React.ReactNode;\n  getKey: (item: T) => string | number;\n}\n\nfunction Select<T>({ \n  items, \n  selectedItem, \n  onChange, \n  renderItem, \n  getKey \n}: SelectProps<T>) {\n  return (\n    <div className=\"select\">\n      {items.map(item => (\n        <div \n          key={getKey(item)} \n          className={item === selectedItem ? 'selected' : ''}\n          onClick={() => onChange(item)}\n        >\n          {renderItem(item)}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Usage\ninterface User {\n  id: number;\n  name: string;\n}\n\n<Select<User>\n  items={users}\n  selectedItem={selectedUser}\n  onChange={setSelectedUser}\n  renderItem={user => user.name}\n  getKey={user => user.id}\n/>\n```\n\n3. **Typing Event Handlers**\n\n```typescript\n// Button click events\nconst handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n  console.log(e.currentTarget.name);\n};\n\n// Form events\nconst handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n  e.preventDefault();\n  // Form submission logic\n};\n\n// Input change events\nconst handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n  setName(e.target.value);\n};\n```\n\n4. **useState with TypeScript**\n\n```typescript\n// Simple types can be inferred\nconst [count, setCount] = useState(0); // inferred as number\nconst [name, setName] = useState(\"\"); // inferred as string\n\n// Complex types or empty states need annotations\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nconst [user, setUser] = useState<User | null>(null);\nconst [items, setItems] = useState<string[]>([]);\n```\n\n5. **useReducer with TypeScript**\n\n```typescript\ntype State = {\n  count: number;\n  loading: boolean;\n  error: string | null;\n};\n\ntype Action =\n  | { type: \"INCREMENT\"; payload: number }\n  | { type: \"DECREMENT\"; payload: number }\n  | { type: \"SET_LOADING\"; payload: boolean }\n  | { type: \"SET_ERROR\"; payload: string | null };\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case \"INCREMENT\":\n      return { ...state, count: state.count + action.payload };\n    case \"DECREMENT\":\n      return { ...state, count: state.count - action.payload };\n    case \"SET_LOADING\":\n      return { ...state, loading: action.payload };\n    case \"SET_ERROR\":\n      return { ...state, error: action.payload };\n    default:\n      // This ensures exhaustive checking of all action types\n      const _exhaustiveCheck: never = action;\n      return state;\n  }\n}\n```\n\n6. **Typing Context API**\n\n```typescript\ninterface AuthContextType {\n  user: User | null;\n  login: (username: string, password: string) => Promise<void>;\n  logout: () => void;\n  loading: boolean;\n  error: string | null;\n}\n\nconst AuthContext = React.createContext<AuthContextType | null>(null);\n\nexport const useAuth = () => {\n  const context = React.useContext(AuthContext);\n  if (!context) {\n    throw new Error(\"useAuth must be used within an AuthProvider\");\n  }\n  return context;\n};\n```\n\n7. **Children Props**\n\n```typescript\n// Option 1: Using React.FC\nconst Panel: React.FC<{ title: string; children: React.ReactNode }> = ({ \n  title, \n  children \n}) => (\n  <div className=\"panel\">\n    <h2>{title}</h2>\n    <div className=\"panel-content\">{children}</div>\n  </div>\n);\n\n// Option 2: Explicitly typing props\ninterface ContainerProps {\n  children: React.ReactNode;\n  className?: string;\n}\n\nfunction Container({ children, className = '' }: ContainerProps) {\n  return <div className={`container ${className}`}>{children}</div>;\n}\n```\n\n8. **Component as props**\n\n```typescript\ninterface PageProps {\n  header: React.ComponentType;\n  content: React.ComponentType<{ id: string }>;\n  id: string;\n}\n\nconst Page = ({ header: Header, content: Content, id }: PageProps) => {\n  return (\n    <div>\n      <Header />\n      <Content id={id} />\n    </div>\n  );\n};\n```\n\n9. **Custom Hook Types**\n\n```typescript\nfunction useLocalStorage<T>(key: string, initialValue: T): [T, (value: T) => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(error);\n      return initialValue;\n    }\n  });\n\n  const setValue = (value: T) => {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n```\n\n10. **Prop Spreading with TypeScript**\n\n```typescript\ninterface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: 'primary' | 'secondary' | 'danger';\n}\n\nconst Button = ({ \n  variant = 'primary', \n  className, \n  children, \n  ...rest \n}: ButtonProps) => {\n  return (\n    <button \n      className={`btn btn-${variant} ${className || ''}`}\n      {...rest}\n    >\n      {children}\n    </button>\n  );\n};\n```",
    "domain": "programming"
  },
  {
    "question": "How do I implement advanced TypeScript patterns in JavaScript code?",
    "answer": "Implementing advanced TypeScript patterns in JavaScript code involves gradually adopting TypeScript features while maintaining compatibility. Here are the key patterns and implementation approaches:\n\n1. **Type Guards Pattern**\n\n```typescript\n// JavaScript implementation\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nfunction processValue(value) {\n  if (isString(value)) {\n    // value is treated as string\n    return value.toUpperCase();\n  } else if (isNumber(value)) {\n    // value is treated as number\n    return value.toFixed(2);\n  } else {\n    throw new TypeError('Value must be string or number');\n  }\n}\n\n// TypeScript equivalent\n/*\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nfunction processValue(value: unknown): string {\n  if (isString(value)) {\n    // TypeScript knows value is string\n    return value.toUpperCase();\n  } else if (isNumber(value)) {\n    // TypeScript knows value is number\n    return value.toFixed(2);\n  } else {\n    throw new TypeError('Value must be string or number');\n  }\n}\n*/\n```\n\n2. **Factory Pattern with Pseudo-Generics**\n\n```javascript\n// JavaScript implementation\nfunction createDataStore(initialValue) {\n  let data = initialValue;\n  \n  return {\n    get() {\n      return data;\n    },\n    set(newValue) {\n      // In TypeScript, this would validate type compatibility\n      data = newValue;\n    },\n    reset() {\n      data = initialValue;\n    }\n  };\n}\n\n// Usage\nconst numberStore = createDataStore(0);\nconst stringStore = createDataStore('hello');\n\n// TypeScript equivalent\n/*\nfunction createDataStore<T>(initialValue: T) {\n  let data: T = initialValue;\n  \n  return {\n    get(): T {\n      return data;\n    },\n    set(newValue: T): void {\n      data = newValue;\n    },\n    reset(): void {\n      data = initialValue;\n    }\n  };\n}\n\nconst numberStore = createDataStore<number>(0);\nconst stringStore = createDataStore<string>('hello');\n*/\n```\n\n3. **Interface-like Validation with JSDoc**\n\n```javascript\n/**\n * @typedef {Object} UserConfig\n * @property {string} username - The user's name\n * @property {number} id - Unique identifier\n * @property {string[]} roles - User roles\n * @property {Object} [preferences] - Optional user preferences\n * @property {string} [preferences.theme] - UI theme preference\n * @property {boolean} [preferences.notifications] - Notification settings\n */\n\n/**\n * Creates a user with validation\n * @param {UserConfig} config - User configuration\n * @returns {Object} The created user object\n */\nfunction createUser(config) {\n  // Validate required properties\n  if (typeof config.username !== 'string') {\n    throw new TypeError('username must be a string');\n  }\n  if (typeof config.id !== 'number') {\n    throw new TypeError('id must be a number');\n  }\n  if (!Array.isArray(config.roles)) {\n    throw new TypeError('roles must be an array');\n  }\n  \n  // Optional property validation\n  if (config.preferences) {\n    if (typeof config.preferences !== 'object') {\n      throw new TypeError('preferences must be an object');\n    }\n    \n    if (config.preferences.theme !== undefined && \n        typeof config.preferences.theme !== 'string') {\n      throw new TypeError('preferences.theme must be a string');\n    }\n    \n    if (config.preferences.notifications !== undefined && \n        typeof config.preferences.notifications !== 'boolean') {\n      throw new TypeError('preferences.notifications must be a boolean');\n    }\n  }\n  \n  return {\n    ...config,\n    createdAt: new Date()\n  };\n}\n```\n\n4. **Union Types with Discriminated Unions**\n\n```javascript\n/**\n * @typedef {Object} SuccessResponse\n * @property {'success'} status - Status indicator\n * @property {any} data - The response data\n */\n\n/**\n * @typedef {Object} ErrorResponse\n * @property {'error'} status - Status indicator\n * @property {string} message - Error message\n * @property {number} [code] - Optional error code\n */\n\n/**\n * @typedef {SuccessResponse|ErrorResponse} ApiResponse\n */\n\n/**\n * Handle API response\n * @param {ApiResponse} response - The API response object\n * @returns {void}\n */\nfunction handleResponse(response) {\n  // Discriminated union pattern with status field as discriminator\n  if (response.status === 'success') {\n    // In TypeScript, response would be typed as SuccessResponse here\n    console.log('Success:', response.data);\n  } else if (response.status === 'error') {\n    // In TypeScript, response would be typed as ErrorResponse here\n    console.error(`Error ${response.code || 'unknown'}:`, response.message);\n  }\n}\n```\n\n5. **Utility Type Functions**\n\n```javascript\n// JavaScript implementation of common TypeScript utility types\n\n/**\n * Creates a partial version of an object type (all properties optional)\n * @template T\n * @param {T} obj - The object to create a partial from\n * @returns {Partial<T>} A new object with all properties made optional\n */\nfunction createPartial(obj) {\n  return { ...obj };\n}\n\n/**\n * Picks specified properties from an object\n * @template T\n * @template K\n * @param {T} obj - Source object\n * @param {K[]} keys - Keys to pick\n * @returns {Pick<T, K>} New object with just the picked properties\n */\nfunction pick(obj, keys) {\n  return keys.reduce((result, key) => {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n    return result;\n  }, {});\n}\n\n/**\n * Omits specified properties from an object\n * @template T\n * @template K\n * @param {T} obj - Source object\n * @param {K[]} keys - Keys to omit\n * @returns {Omit<T, K>} New object without the omitted properties\n */\nfunction omit(obj, keys) {\n  return Object.keys(obj)\n    .filter(key => !keys.includes(key))\n    .reduce((result, key) => {\n      result[key] = obj[key];\n      return result;\n    }, {});\n}\n```\n\nThese patterns help you gradually adopt TypeScript thinking in JavaScript codebases, making eventual migration smoother. Using JSDoc comments provides some type checking benefits even in plain JavaScript when using editors like VS Code.",
    "domain": "programming"
  }
]
