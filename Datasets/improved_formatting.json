[
  {
    "question": "How do I add error handling to my Python code?",
    "answer": "To add error handling in Python, use try-except blocks:\n\n```python\ntry:\n    # Code that might raise an exception\n    result = 10 / user_input\nexcept ZeroDivisionError:\n    # Handle specific error\n    print(\"Cannot divide by zero!\")\nexcept ValueError:\n    # Handle another specific error\n    print(\"Please enter a valid number!\")\nexcept Exception as e:\n    # Handle any other exceptions\n    print(f\"An unexpected error occurred: {e}\")\nelse:\n    # Runs if no exceptions occur\n    print(f\"The result is {result}\")\nfinally:\n    # Always executes, regardless of exceptions\n    print(\"Execution completed\")\n```\n\nBest practices for error handling include:\n\n1. Catch specific exceptions rather than all exceptions\n2. Keep try blocks as small as possible\n3. Log exceptions with context information\n4. Use custom exceptions for application-specific errors\n5. Don't use exceptions for flow control\n6. Clean up resources properly in finally blocks",
    "domain": "programming"
  },
  {
    "question": "What is a REST API?",
    "answer": "A REST (Representational State Transfer) API is an architectural style for designing networked applications. Key characteristics include:\n\n1. **Stateless** - Server doesn't store client context between requests\n2. **Client-Server** - Separation of concerns between client and server\n3. **Cacheable** - Responses must define themselves as cacheable or non-cacheable\n4. **Uniform Interface** - Resources are identified by URLs with standardized methods\n5. **Layered System** - Client cannot tell if connected directly to server or intermediary\n\nRESTful APIs typically use HTTP methods:\n- GET: Retrieve resources\n- POST: Create new resources\n- PUT: Update existing resources\n- DELETE: Remove resources\n- PATCH: Partially update resources\n\nResponses usually return appropriate HTTP status codes (200 OK, 201 Created, 400 Bad Request, etc.) and data formatted as JSON or XML.\n\nExample REST API endpoint: `GET /api/users/123` to retrieve information about user with ID 123.",
    "domain": "web_development"
  },
  {
    "question": "Can you explain object-oriented programming concepts?",
    "answer": "# Object-Oriented Programming Concepts\n\n## Core Principles\n\n### 1. Classes and Objects\n- **Classes**: Blueprints for creating objects\n- **Objects**: Instances of classes with state (attributes) and behavior (methods)\n\n### 2. Encapsulation\n- Bundling data and methods that work on that data within one unit\n- Restricting direct access to some object components\n- Implemented with access modifiers (public, private, protected)\n\n### 3. Inheritance\n- Mechanism where a new class inherits properties and methods from an existing class\n- Promotes code reuse and establishes a relationship between classes\n- Base class (parent) and derived class (child) relationship\n\n### 4. Polymorphism\n- Ability of different classes to respond to the same message in different ways\n- Method overriding: Same method name, different implementation in subclasses\n- Method overloading: Same method name, different parameters\n\n### 5. Abstraction\n- Hiding complex implementation details while showing only essential features\n- Achieved through abstract classes and interfaces\n\n## Key OOP Concepts in Practice\n\n- **Constructor**: Special method for initializing objects\n- **Destructor**: Method called when object is destroyed\n- **Static members**: Belong to class rather than instances\n- **Interfaces**: Define contracts that classes must implement\n- **Composition**: Building complex objects from simpler ones\n\nThese principles help create more modular, maintainable, and scalable software.",
    "domain": "programming"
  },
  {
    "question": "What are common HTTP status codes?",
    "answer": "# Common HTTP Status Codes\n\n## Informational (1xx)\n- **100 Continue**: Server has received request headers and client should proceed\n- **101 Switching Protocols**: Server is switching protocols as requested\n\n## Successful (2xx)\n- **200 OK**: Request successful\n- **201 Created**: Resource successfully created\n- **204 No Content**: Request successful, but no content returned\n\n## Redirection (3xx)\n- **301 Moved Permanently**: Resource moved permanently\n- **302 Found**: Resource temporarily located elsewhere\n- **304 Not Modified**: Resource unchanged since last request\n\n## Client Errors (4xx)\n- **400 Bad Request**: Server cannot process due to client error\n- **401 Unauthorized**: Authentication required\n- **403 Forbidden**: Server refuses to fulfill request (even with authentication)\n- **404 Not Found**: Resource not found\n- **429 Too Many Requests**: Rate limiting applied\n\n## Server Errors (5xx)\n- **500 Internal Server Error**: Generic server error\n- **502 Bad Gateway**: Invalid response from upstream server\n- **503 Service Unavailable**: Server temporarily unavailable\n- **504 Gateway Timeout**: Upstream server didn't respond in time\n\nUnderstanding these status codes helps with debugging and properly handling different response scenarios in applications.",
    "domain": "web_development"
  },
  {
    "question": "How does public key cryptography work?",
    "answer": "# Public Key Cryptography Explained\n\n## Core Concepts\n\nPublic key cryptography (asymmetric cryptography) uses a pair of mathematically related keys:\n\n- **Public key**: Freely shared with anyone\n- **Private key**: Kept secret by the owner\n\n## Key Operations\n\n1. **Encryption**\n   - Message encrypted with recipient's **public key**\n   - Can only be decrypted with recipient's **private key**\n   - Ensures confidentiality\n\n2. **Digital Signatures**\n   - Message signed with sender's **private key**\n   - Verified using sender's **public key**\n   - Provides authentication and non-repudiation\n\n## Common Algorithms\n\n- **RSA**: Based on the difficulty of factoring large prime numbers\n- **ECC (Elliptic Curve Cryptography)**: Based on algebraic structure of elliptic curves\n- **Diffie-Hellman**: Used for secure key exchange over insecure channels\n- **DSA (Digital Signature Algorithm)**: Specifically for digital signatures\n\n## Real-World Applications\n\n- **HTTPS/TLS**: Securing web browsing\n- **SSH**: Secure remote access\n- **PGP/GPG**: Email encryption\n- **Blockchain**: Cryptocurrency transactions\n- **Code signing**: Software authentication\n\nThe strength of public key cryptography comes from mathematical problems that are easy to compute in one direction but extremely difficult to reverse without the private key.",
    "domain": "cybersecurity"
  },
  {
    "question": "How do I implement a binary search algorithm?",
    "answer": "# Binary Search Algorithm Implementation\n\n## Overview\nBinary search is an efficient algorithm for finding a target value in a sorted array by repeatedly dividing the search range in half.\n\n## Time Complexity\n- **Best case**: O(1) - target found in the middle\n- **Average case**: O(log n)\n- **Worst case**: O(log n)\n\n## Algorithm Steps\n1. Compare target with middle element\n2. If target equals middle element, search successful\n3. If target less than middle, search left half\n4. If target greater than middle, search right half\n5. Repeat until found or search space is empty\n\n## Python Implementation\n\n```python\ndef binary_search(arr, target):\n    \"\"\"Binary search implementation\n    \n    Args:\n        arr (list): Sorted list to search in\n        target: Value to find\n        \n    Returns:\n        int: Index of target if found, -1 otherwise\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2  # Avoid potential overflow\n        \n        # Check if target is at mid\n        if arr[mid] == target:\n            return mid\n        \n        # If target greater, ignore left half\n        elif arr[mid] < target:\n            left = mid + 1\n        \n        # If target smaller, ignore right half\n        else:\n            right = mid - 1\n    \n    # Target not found\n    return -1\n\n# Example usage\nsorted_array = [2, 5, 8, 12, 16, 23, 38, 45, 56, 72, 91]\nprint(f\"Index of 23: {binary_search(sorted_array, 23)}\")  # Should return 5\nprint(f\"Index of 11: {binary_search(sorted_array, 11)}\")  # Should return -1\n```\n\n## Key Considerations\n- Input array **must be sorted**\n- Works best for random access data structures (arrays)\n- Significantly faster than linear search for large datasets",
    "domain": "algorithms"
  },
  {
    "question": "What is a firewall and how does it work?",
    "answer": "# Firewalls: Protection for Networks and Systems\n\n## Definition\nA firewall is a network security device or software that monitors and filters incoming and outgoing network traffic based on predefined security rules.\n\n## Types of Firewalls\n\n1. **Packet Filtering Firewalls**\n   - Examine packets in isolation\n   - Filter based on source/destination IP, ports, protocols\n   - Stateless - don't track connection state\n   - Fast but limited security capabilities\n\n2. **Stateful Inspection Firewalls**\n   - Track the state of active connections\n   - Make filtering decisions based on context\n   - More secure than packet filtering\n\n3. **Proxy Firewalls (Application-Level Gateways)**\n   - Act as intermediaries between clients and servers\n   - Inspect packets at application layer\n   - Provide deep content inspection\n   - Higher security but more resource-intensive\n\n4. **Next-Generation Firewalls (NGFW)**\n   - Combine traditional firewall with additional capabilities\n   - Include IPS, deep packet inspection, application awareness\n   - Can enforce security policies based on applications\n\n5. **Web Application Firewalls (WAF)**\n   - Specifically protect web applications\n   - Filter HTTP traffic\n   - Defend against SQL injection, XSS, CSRF attacks\n\n## Deployment Models\n\n- **Network Firewalls**: Protect entire networks\n- **Host-based Firewalls**: Protect individual devices\n- **Cloud Firewalls**: Secure cloud environments\n\n## Common Firewall Rules\n\n- Allow/block specific ports (e.g., allow 443 for HTTPS)\n- Allow/block IP addresses or ranges\n- Restrict traffic by protocol\n- Limit outbound connections\n- Time-based access controls\n\nFirewalls are a critical first line of defense but should be part of a comprehensive security strategy including other measures like encryption, authentication, and monitoring systems.",
    "domain": "cybersecurity"
  },
  {
    "question": "What is dependency injection?",
    "answer": "# Dependency Injection Explained\n\n## Core Concept\nDependency Injection (DI) is a design pattern that implements Inversion of Control (IoC) for resolving dependencies. It removes the responsibility of creating dependencies from classes that use them.\n\n## Benefits\n\n- **Improved testability**: Mock dependencies for unit testing\n- **Reduced coupling**: Classes don't need to know how dependencies are created\n- **Enhanced modularity**: Components are more independent\n- **Better code maintenance**: Dependencies are explicit\n- **Greater flexibility**: Change implementations without modifying dependent code\n\n## Types of Dependency Injection\n\n1. **Constructor Injection**\n   - Dependencies provided through constructors\n   - Makes dependencies explicit and mandatory\n   - Example:\n   ```java\n   public class OrderService {\n       private final PaymentProcessor paymentProcessor;\n       \n       public OrderService(PaymentProcessor paymentProcessor) {\n           this.paymentProcessor = paymentProcessor;\n       }\n   }\n   ```\n\n2. **Setter Injection**\n   - Dependencies provided through setter methods\n   - Allows optional dependencies\n   - Example:\n   ```java\n   public class OrderService {\n       private PaymentProcessor paymentProcessor;\n       \n       public void setPaymentProcessor(PaymentProcessor paymentProcessor) {\n           this.paymentProcessor = paymentProcessor;\n       }\n   }\n   ```\n\n3. **Interface Injection**\n   - Classes implement an interface that declares injection methods\n   - Less common in modern frameworks\n\n## Dependency Injection Containers\n\nPopular DI frameworks by language:\n\n- **Java**: Spring, Guice, Dagger\n- **C#**: ASP.NET Core IoC, Autofac, Ninject\n- **JavaScript**: Angular DI, InversifyJS, tsyringe\n- **PHP**: Symfony DI, PHP-DI\n- **Python**: Python dependency_injector, Injector\n\nThese containers manage object creation and injection, reducing boilerplate code and ensuring consistent dependency resolution.",
    "domain": "programming"
  },
  {
    "question": "What is Docker and how do I use it?",
    "answer": "# Docker: Containerization Made Simple\n\n## What Is Docker?\n\nDocker is a platform that uses containerization technology to create, deploy, and run applications in isolated environments called containers. Containers package an application with all its dependencies, ensuring consistent behavior across different environments.\n\n## Key Components\n\n- **Docker Engine**: Runtime that builds and runs containers\n- **Docker Images**: Templates with code, runtime, libraries, and dependencies\n- **Containers**: Running instances of images\n- **Dockerfile**: Text file with instructions to build an image\n- **Docker Hub**: Registry for sharing and distributing images\n- **Docker Compose**: Tool for defining multi-container applications\n\n## Basic Docker Commands\n\n```bash\n# Build an image from a Dockerfile\ndocker build -t myapp:latest .\n\n# Run a container from an image\ndocker run -d -p 8080:80 --name mycontainer myapp:latest\n\n# List running containers\ndocker ps\n\n# Stop a container\ndocker stop mycontainer\n\n# Remove a container\ndocker rm mycontainer\n\n# List images\ndocker images\n\n# Pull an image from Docker Hub\ndocker pull nginx:latest\n\n# Access container shell\ndocker exec -it mycontainer bash\n```\n\n## Sample Dockerfile\n\n```dockerfile\n# Use official Node.js image as base\nFROM node:14-alpine\n\n# Set working directory\nWORKDIR /app\n\n# Copy package.json and install dependencies\nCOPY package*.json ./\nRUN npm install\n\n# Copy application code\nCOPY . .\n\n# Expose port\nEXPOSE 3000\n\n# Start application\nCMD [\"npm\", \"start\"]\n```\n\n## Docker Compose Example\n\n```yaml\nversion: '3'\nservices:\n  webapp:\n    build: .\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - database\n    environment:\n      DB_HOST: database\n      DB_PORT: 5432\n  \n  database:\n    image: postgres:12\n    volumes:\n      - db-data:/var/lib/postgresql/data\n    environment:\n      POSTGRES_PASSWORD: example\n\nvolumes:\n  db-data:\n```\n\n## Benefits\n\n- **Consistency**: Same environment from development to production\n- **Isolation**: Applications run independently without conflicts\n- **Efficiency**: Lightweight compared to virtual machines\n- **Scalability**: Easy to scale containers horizontally\n- **Portability**: Run anywhere Docker is installed\n\nDocker simplifies development workflows and enables microservices architecture.",
    "domain": "devops"
  },
  {
    "question": "What's the difference between supervised and unsupervised learning?",
    "answer": "# Supervised vs. Unsupervised Learning\n\n## Supervised Learning\n\n### Definition\nTraining a model on labeled data where the desired output is known\n\n### Key Characteristics\n- Requires paired input-output data\n- Goal is to learn a mapping function\n- Performance can be objectively measured\n- Training is directed toward specific predictions\n\n### Common Algorithms\n- Linear/Logistic Regression\n- Decision Trees and Random Forests\n- Support Vector Machines\n- Neural Networks\n- K-Nearest Neighbors\n\n### Applications\n- Classification (spam detection, image recognition)\n- Regression (price prediction, demand forecasting)\n- Sentiment analysis\n- Medical diagnosis\n\n### Advantages\n- Clear performance metrics\n- Direct business applications\n- Well-understood theoretical properties\n\n### Disadvantages\n- Requires labeled data (often expensive to obtain)\n- May not discover unexpected patterns\n- Can overfit to training data\n\n## Unsupervised Learning\n\n### Definition\nTraining a model on unlabeled data to find patterns or structure\n\n### Key Characteristics\n- Works with unlabeled data\n- Discovers hidden patterns autonomously\n- No explicit correct answers\n- Often exploratory in nature\n\n### Common Algorithms\n- K-Means Clustering\n- Hierarchical Clustering\n- Principal Component Analysis (PCA)\n- Autoencoders\n- Association Rules\n\n### Applications\n- Customer segmentation\n- Anomaly detection\n- Feature extraction/dimensionality reduction\n- Recommendation systems\n\n### Advantages\n- Works with unlabeled data (more abundant)\n- Can discover unexpected patterns\n- Useful for exploratory data analysis\n\n### Disadvantages\n- Results can be subjective\n- Harder to validate accuracy\n- May find patterns with no practical relevance\n\n## Hybrid Approaches\n\n- **Semi-supervised learning**: Uses both labeled and unlabeled data\n- **Self-supervised learning**: Creates labels from unlabeled data\n- **Reinforcement learning**: Learns through interaction with environment\n\nThe choice between approaches depends on data availability, problem type, and specific objectives.",
    "domain": "data_science"
  }
]
