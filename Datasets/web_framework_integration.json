[
  {
    "question": "How do I use React with JavaScript and TypeScript?",
    "answer": "# Using React with JavaScript\n\n```javascript\nimport React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `Count: ${count}`;\n  }, [count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n\nReactDOM.render(<Counter />, document.getElementById('root'));\n```\n\n# Using React with TypeScript\n\n```typescript\nimport React, { useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\ninterface CounterProps {\n  initialValue?: number;\n  label?: string;\n}\n\nconst Counter: React.FC<CounterProps> = ({ initialValue = 0, label = 'Count' }) => {\n  const [count, setCount] = useState<number>(initialValue);\n\n  useEffect(() => {\n    document.title = `${label}: ${count}`;\n  }, [count, label]);\n\n  return (\n    <div>\n      <p>{label}: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n};\n\nReactDOM.render(<Counter />, document.getElementById('root'));\n```\n\nKey differences when using TypeScript with React:\n\n1. **Props interface definition**: Define interfaces for component props\n2. **Type annotations for hooks**: Specify types for useState and other hooks\n3. **Function component typing**: Use React.FC<Props> or function declarations with typed props\n4. **Event handling**: Type event handlers correctly for DOM events\n5. **Better IDE support**: Get autocomplete for props and state\n\nTo set up a TypeScript React project:\n\n```bash\n# For Create React App\nnpx create-react-app my-app --template typescript\n\n# For Next.js\nnpx create-next-app@latest my-app --typescript\n\n# For Vite\nnpm create vite@latest my-app -- --template react-ts\n```",
    "domain": "web_development"
  },
  {
    "question": "How do I use Vue.js with JavaScript and TypeScript?",
    "answer": "# Using Vue.js with JavaScript\n\n```javascript\n// Vue 3 with JavaScript\nimport { createApp, ref, onMounted } from 'vue';\n\nconst app = createApp({\n  setup() {\n    const count = ref(0);\n    const increment = () => { count.value++ };\n    \n    onMounted(() => {\n      console.log('Component mounted');\n    });\n    \n    return {\n      count,\n      increment\n    };\n  },\n  template: `\n    <div>\n      <p>Count: {{ count }}</p>\n      <button @click=\"increment\">Increment</button>\n    </div>\n  `\n});\n\napp.mount('#app');\n```\n\n# Using Vue.js with TypeScript\n\n```typescript\n// Vue 3 with TypeScript\nimport { defineComponent, ref, onMounted } from 'vue';\n\nexport default defineComponent({\n  props: {\n    initialValue: {\n      type: Number,\n      default: 0\n    },\n    label: {\n      type: String,\n      default: 'Count'\n    }\n  },\n  setup(props) {\n    // Type is automatically inferred as Ref<number>\n    const count = ref(props.initialValue);\n    \n    // Type is inferred as () => void\n    const increment = () => { count.value++ };\n    \n    onMounted(() => {\n      console.log('Component mounted with count:', count.value);\n    });\n    \n    return {\n      count,\n      increment\n    };\n  }\n});\n```\n\n**Vue Single-File Component with TypeScript**\n\n```html\n<!-- Counter.vue -->\n<script lang=\"ts\">\nimport { defineComponent, ref } from 'vue';\n\nexport default defineComponent({\n  props: {\n    initialValue: { type: Number, default: 0 },\n    label: { type: String, default: 'Count' }\n  },\n  setup(props) {\n    const count = ref(props.initialValue);\n    \n    function increment(): void {\n      count.value++;\n    }\n    \n    return { count, increment };\n  }\n});\n</script>\n\n<template>\n  <div>\n    <p>{{ label }}: {{ count }}</p>\n    <button @click=\"increment\">Increment</button>\n  </div>\n</template>\n```\n\nTo set up a TypeScript Vue project:\n\n```bash\n# Vue CLI\nnpm install -g @vue/cli\nvue create my-vue-app\n# Select TypeScript option during setup\n\n# Vite\nnpm create vite@latest my-vue-app -- --template vue-ts\n```\n\nKey differences when using TypeScript with Vue:\n\n1. **defineComponent**: Use this helper for proper type inference\n2. **Props definition**: Define prop types and defaults\n3. **Script setup with TS**: Use `<script lang=\"ts\" setup>` for Composition API\n4. **Type annotations**: Explicitly type refs, reactive objects, and functions\n5. **Computed properties**: Type return values from computed properties",
    "domain": "web_development"
  },
  {
    "question": "How do I use Angular with TypeScript?",
    "answer": "# Using Angular with TypeScript\n\nAngular is built with TypeScript from the ground up and provides strong typing throughout. Here's how to work with Angular and TypeScript:\n\n**Component Example**\n\n```typescript\n// product-list.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport { ProductService } from '../product.service';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description: string;\n}\n\n@Component({\n  selector: 'app-product-list',\n  templateUrl: './product-list.component.html',\n  styleUrls: ['./product-list.component.css']\n})\nexport class ProductListComponent implements OnInit {\n  products: Product[] = [];\n  selectedProduct: Product | null = null;\n  loading = true;\n  error: string | null = null;\n\n  constructor(private productService: ProductService) {}\n\n  ngOnInit(): void {\n    this.getProducts();\n  }\n\n  getProducts(): void {\n    this.productService.getProducts().subscribe({\n      next: (products) => {\n        this.products = products;\n        this.loading = false;\n      },\n      error: (err) => {\n        this.error = 'Failed to load products';\n        this.loading = false;\n        console.error(err);\n      }\n    });\n  }\n\n  selectProduct(product: Product): void {\n    this.selectedProduct = product;\n  }\n}\n```\n\n**Template**\n\n```html\n<!-- product-list.component.html -->\n<div class=\"product-container\">\n  <h2>Products</h2>\n  \n  <div *ngIf=\"loading\">Loading products...</div>\n  \n  <div *ngIf=\"error\" class=\"error\">{{ error }}</div>\n  \n  <ul *ngIf=\"!loading && !error\">\n    <li *ngFor=\"let product of products\" (click)=\"selectProduct(product)\">\n      {{ product.name }} - {{ product.price | currency }}\n    </li>\n  </ul>\n  \n  <div *ngIf=\"selectedProduct\" class=\"product-detail\">\n    <h3>{{ selectedProduct.name }}</h3>\n    <p>{{ selectedProduct.description }}</p>\n    <p>Price: {{ selectedProduct.price | currency }}</p>\n  </div>\n</div>\n```\n\n**Service**\n\n```typescript\n// product.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse } from '@angular/common/http';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\n\nexport interface Product {\n  id: number;\n  name: string;\n  price: number;\n  description: string;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class ProductService {\n  private apiUrl = 'https://api.example.com/products';\n\n  constructor(private http: HttpClient) {}\n\n  getProducts(): Observable<Product[]> {\n    return this.http.get<Product[]>(this.apiUrl)\n      .pipe(catchError(this.handleError));\n  }\n\n  getProduct(id: number): Observable<Product> {\n    return this.http.get<Product>(`${this.apiUrl}/${id}`)\n      .pipe(catchError(this.handleError));\n  }\n\n  private handleError(error: HttpErrorResponse) {\n    let errorMessage = 'An unknown error occurred!';\n    \n    if (error.error instanceof ErrorEvent) {\n      // Client-side error\n      errorMessage = `Error: ${error.error.message}`;\n    } else {\n      // Server-side error\n      errorMessage = `Error Code: ${error.status}\\nMessage: ${error.message}`;\n    }\n    \n    return throwError(() => new Error(errorMessage));\n  }\n}\n```\n\n**Setting up a new Angular project with TypeScript**\n\n```bash\n# Install Angular CLI\nnpm install -g @angular/cli\n\n# Create a new project\nng new my-angular-app\n\n# Generate a component\nng generate component product-list\n\n# Generate a service\nng generate service product\n```\n\nKey TypeScript features in Angular:\n\n1. **Decorators**: @Component, @Injectable, etc., to provide metadata\n2. **Interfaces**: Define data shapes for components, services, and API responses\n3. **Type annotations**: For component properties, method parameters, and return types\n4. **Generics**: Used with services, observables, and collections\n5. **Access modifiers**: public, private, protected for component/service properties and methods\n6. **Strongly-typed forms**: FormGroup, FormControl with typed validation\n7. **Type checking in templates**: With strict template type checking enabled",
    "domain": "web_development"
  },
  {
    "question": "How do I integrate state management libraries like Redux and MobX with TypeScript?",
    "answer": "# Redux with TypeScript\n\n```typescript\n// Store Types\nexport interface AppState {\n  products: ProductState;\n  cart: CartState;\n  user: UserState;\n}\n\nexport interface ProductState {\n  items: Product[];\n  loading: boolean;\n  error: string | null;\n}\n\nexport interface CartState {\n  items: CartItem[];\n  total: number;\n}\n\nexport interface UserState {\n  profile: User | null;\n  isAuthenticated: boolean;\n}\n\n// Action Types\nexport enum ProductActionTypes {\n  FETCH_PRODUCTS_REQUEST = 'FETCH_PRODUCTS_REQUEST',\n  FETCH_PRODUCTS_SUCCESS = 'FETCH_PRODUCTS_SUCCESS',\n  FETCH_PRODUCTS_FAILURE = 'FETCH_PRODUCTS_FAILURE',\n}\n\ninterface FetchProductsRequestAction {\n  type: typeof ProductActionTypes.FETCH_PRODUCTS_REQUEST;\n}\n\ninterface FetchProductsSuccessAction {\n  type: typeof ProductActionTypes.FETCH_PRODUCTS_SUCCESS;\n  payload: Product[];\n}\n\ninterface FetchProductsFailureAction {\n  type: typeof ProductActionTypes.FETCH_PRODUCTS_FAILURE;\n  payload: string;\n}\n\nexport type ProductActionTypes = \n  | FetchProductsRequestAction\n  | FetchProductsSuccessAction\n  | FetchProductsFailureAction;\n\n// Action Creators\nexport const fetchProducts = (): ThunkAction<void, AppState, unknown, Action<string>> => {\n  return async (dispatch) => {\n    dispatch({ type: ProductActionTypes.FETCH_PRODUCTS_REQUEST });\n    \n    try {\n      const response = await api.getProducts();\n      dispatch({\n        type: ProductActionTypes.FETCH_PRODUCTS_SUCCESS,\n        payload: response.data\n      });\n    } catch (error) {\n      dispatch({\n        type: ProductActionTypes.FETCH_PRODUCTS_FAILURE,\n        payload: error.message\n      });\n    }\n  };\n};\n\n// Reducer\nconst initialState: ProductState = {\n  items: [],\n  loading: false,\n  error: null\n};\n\nexport const productReducer = (state = initialState, action: ProductActionTypes): ProductState => {\n  switch (action.type) {\n    case ProductActionTypes.FETCH_PRODUCTS_REQUEST:\n      return { ...state, loading: true, error: null };\n    case ProductActionTypes.FETCH_PRODUCTS_SUCCESS:\n      return { ...state, loading: false, items: action.payload };\n    case ProductActionTypes.FETCH_PRODUCTS_FAILURE:\n      return { ...state, loading: false, error: action.payload };\n    default:\n      return state;\n  }\n};\n\n// Using in a Component\nimport React, { useEffect } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchProducts } from './actions';\nimport { AppState } from './types';\n\nconst ProductList: React.FC = () => {\n  const dispatch = useDispatch();\n  const { items, loading, error } = useSelector((state: AppState) => state.products);\n  \n  useEffect(() => {\n    dispatch(fetchProducts());\n  }, [dispatch]);\n  \n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error}</p>;\n  \n  return (\n    <div>\n      <h2>Products</h2>\n      <ul>\n        {items.map(product => (\n          <li key={product.id}>{product.name} - ${product.price}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n```\n\n# MobX with TypeScript\n\n```typescript\n// Store Definition\nimport { makeAutoObservable, runInAction } from 'mobx';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\nclass ProductStore {\n  products: Product[] = [];\n  loading = false;\n  error: string | null = null;\n  \n  constructor() {\n    makeAutoObservable(this);\n  }\n  \n  async fetchProducts() {\n    this.loading = true;\n    this.error = null;\n    \n    try {\n      const response = await fetch('https://api.example.com/products');\n      if (!response.ok) throw new Error('Network response was not ok');\n      \n      const data = await response.json();\n      \n      runInAction(() => {\n        this.products = data;\n        this.loading = false;\n      });\n    } catch (error) {\n      runInAction(() => {\n        this.error = error.message;\n        this.loading = false;\n      });\n    }\n  }\n  \n  get totalProducts() {\n    return this.products.length;\n  }\n  \n  get totalPrice() {\n    return this.products.reduce((sum, product) => sum + product.price, 0);\n  }\n}\n\n// Root Store Pattern\nclass RootStore {\n  productStore: ProductStore;\n  cartStore: CartStore;\n  userStore: UserStore;\n  \n  constructor() {\n    this.productStore = new ProductStore();\n    this.cartStore = new CartStore(this);\n    this.userStore = new UserStore(this);\n  }\n}\n\n// Context Setup\nimport React, { createContext, useContext } from 'react';\n\nconst StoreContext = createContext<RootStore | null>(null);\n\nexport const StoreProvider: React.FC = ({ children }) => {\n  const store = new RootStore();\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n};\n\nexport const useStore = () => {\n  const store = useContext(StoreContext);\n  if (!store) {\n    throw new Error('useStore must be used within StoreProvider');\n  }\n  return store;\n};\n\n// Using in a Component with Observer\nimport React, { useEffect } from 'react';\nimport { observer } from 'mobx-react-lite';\nimport { useStore } from './stores';\n\nconst ProductList = observer(() => {\n  const { productStore } = useStore();\n  const { products, loading, error, fetchProducts } = productStore;\n  \n  useEffect(() => {\n    fetchProducts();\n  }, [fetchProducts]);\n  \n  if (loading) return <p>Loading...</p>;\n  if (error) return <p>Error: {error}</p>;\n  \n  return (\n    <div>\n      <h2>Products ({products.length})</h2>\n      <p>Total price: ${productStore.totalPrice.toFixed(2)}</p>\n      <ul>\n        {products.map(product => (\n          <li key={product.id}>{product.name} - ${product.price}</li>\n        ))}\n      </ul>\n    </div>\n  );\n});\n```\n\n# Key Differences and Benefits\n\n1. **Redux with TypeScript**\n   - Strong typing for actions and reducers\n   - Type-safe action creators\n   - Enhanced type checking for selectors\n   - Middleware typings (e.g., redux-thunk with ThunkAction)\n\n2. **MobX with TypeScript**\n   - Automatic type inference for observable properties\n   - Type-safe actions and computed properties\n   - Strong typing for store instances\n   - Better IDE support for store methods and properties\n\n3. **Benefits of TypeScript Integration**\n   - Catching type errors at compile time\n   - Improved developer experience with autocompletion\n   - Better refactoring support\n   - Self-documenting code through interfaces and types\n   - Enhanced IDE support for both libraries",
    "domain": "web_development"
  },
  {
    "question": "How do I implement server-side rendering (SSR) with Next.js and TypeScript?",
    "answer": "# Server-Side Rendering with Next.js and TypeScript\n\nNext.js provides robust TypeScript support for server-side rendering. Here's a comprehensive guide:\n\n## Basic Setup\n\n```bash\n# Create a new Next.js project with TypeScript\nnpx create-next-app@latest my-nextjs-app --typescript\ncd my-nextjs-app\n```\n\n## Page with getStaticProps (Static Generation)\n\n```typescript\n// pages/products/index.tsx\nimport { GetStaticProps } from 'next';\nimport Link from 'next/link';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description: string;\n}\n\ninterface ProductsPageProps {\n  products: Product[];\n}\n\nexport const getStaticProps: GetStaticProps<ProductsPageProps> = async () => {\n  // Fetch data at build time\n  const res = await fetch('https://api.example.com/products');\n  const products: Product[] = await res.json();\n  \n  // Return as props\n  return {\n    props: {\n      products\n    },\n    // Re-generate page every 10 minutes (600 seconds)\n    revalidate: 600\n  };\n};\n\nconst ProductsPage = ({ products }: ProductsPageProps) => {\n  return (\n    <div>\n      <h1>Products</h1>\n      <ul>\n        {products.map((product) => (\n          <li key={product.id}>\n            <Link href={`/products/${product.id}`}>\n              <a>\n                {product.name} - ${product.price}\n              </a>\n            </Link>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n};\n\nexport default ProductsPage;\n```\n\n## Page with getServerSideProps (Server-Side Rendering)\n\n```typescript\n// pages/dashboard.tsx\nimport { GetServerSideProps } from 'next';\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface DashboardProps {\n  user: User;\n  lastLogin: string;\n}\n\nexport const getServerSideProps: GetServerSideProps<DashboardProps> = async (context) => {\n  // Get cookie from request\n  const { req } = context;\n  const token = req.cookies.token;\n  \n  if (!token) {\n    // If no token, redirect to login\n    return {\n      redirect: {\n        destination: '/login',\n        permanent: false,\n      },\n    };\n  }\n  \n  try {\n    // Authenticate and fetch data on each request\n    const userRes = await fetch('https://api.example.com/user', {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    \n    if (!userRes.ok) throw new Error('Failed to fetch user');\n    \n    const user: User = await userRes.json();\n    const lastLogin = new Date().toISOString();\n    \n    return {\n      props: { user, lastLogin }\n    };\n  } catch (error) {\n    // Handle errors\n    return {\n      redirect: {\n        destination: '/login?error=session_expired',\n        permanent: false,\n      },\n    };\n  }\n};\n\nconst Dashboard = ({ user, lastLogin }: DashboardProps) => {\n  return (\n    <div>\n      <h1>Welcome, {user.name}!</h1>\n      <p>Email: {user.email}</p>\n      <p>Last login: {new Date(lastLogin).toLocaleString()}</p>\n    </div>\n  );\n};\n\nexport default Dashboard;\n```\n\n## Dynamic Routes with getStaticPaths\n\n```typescript\n// pages/products/[id].tsx\nimport { GetStaticPaths, GetStaticProps } from 'next';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description: string;\n  imageUrl: string;\n}\n\ninterface ProductPageProps {\n  product: Product;\n}\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  // Fetch all product IDs\n  const res = await fetch('https://api.example.com/products');\n  const products: Product[] = await res.json();\n  \n  // Generate paths for all products\n  const paths = products.map((product) => ({\n    params: { id: product.id.toString() }\n  }));\n  \n  return {\n    paths,\n    // 'blocking' means pages not generated at build time will\n    // be server-rendered on demand\n    fallback: 'blocking'\n  };\n};\n\nexport const getStaticProps: GetStaticProps<ProductPageProps, { id: string }> = async ({ params }) => {\n  if (!params?.id) {\n    return { notFound: true };\n  }\n  \n  try {\n    // Fetch product details\n    const res = await fetch(`https://api.example.com/products/${params.id}`);\n    \n    if (!res.ok) {\n      // No product found with this ID\n      return { notFound: true };\n    }\n    \n    const product: Product = await res.json();\n    \n    return {\n      props: { product },\n      // Revalidate every hour\n      revalidate: 3600\n    };\n  } catch (error) {\n    // Handle fetch errors\n    return { notFound: true };\n  }\n};\n\nconst ProductPage = ({ product }: ProductPageProps) => {\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>Price: ${product.price}</p>\n      <img src={product.imageUrl} alt={product.name} width=\"400\" />\n      <p>{product.description}</p>\n    </div>\n  );\n};\n\nexport default ProductPage;\n```\n\n## API Routes with TypeScript\n\n```typescript\n// pages/api/products.ts\nimport { NextApiRequest, NextApiResponse } from 'next';\nimport { connectToDatabase } from '../../lib/mongodb';\n\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n  description: string;\n}\n\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse<Product[] | { message: string }>\n) {\n  // Only allow GET requests\n  if (req.method !== 'GET') {\n    res.setHeader('Allow', ['GET']);\n    return res.status(405).json({ message: `Method ${req.method} not allowed` });\n  }\n  \n  try {\n    const { db } = await connectToDatabase();\n    const products = await db\n      .collection('products')\n      .find({})\n      .sort({ name: 1 })\n      .toArray();\n      \n    res.status(200).json(products);\n  } catch (error) {\n    res.status(500).json({ message: 'Failed to fetch products' });\n  }\n}\n```\n\n## Custom App with TypeScript\n\n```typescript\n// pages/_app.tsx\nimport { AppProps } from 'next/app';\nimport { ThemeProvider } from 'styled-components';\nimport { Provider } from 'react-redux';\nimport { store } from '../store';\nimport Layout from '../components/Layout';\nimport '../styles/globals.css';\n\n// Theme definition\nconst theme = {\n  colors: {\n    primary: '#0070f3',\n    secondary: '#ff4081',\n    background: '#f5f5f5',\n    text: '#333333',\n  },\n  breakpoints: {\n    mobile: '576px',\n    tablet: '768px',\n    desktop: '1024px',\n  },\n};\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  return (\n    <Provider store={store}>\n      <ThemeProvider theme={theme}>\n        <Layout>\n          <Component {...pageProps} />\n        </Layout>\n      </ThemeProvider>\n    </Provider>\n  );\n}\n\nexport default MyApp;\n```\n\n## Custom Document with TypeScript\n\n```typescript\n// pages/_document.tsx\nimport Document, { Html, Head, Main, NextScript, DocumentContext } from 'next/document';\nimport { ServerStyleSheet } from 'styled-components';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx: DocumentContext) {\n    const sheet = new ServerStyleSheet();\n    const originalRenderPage = ctx.renderPage;\n\n    try {\n      ctx.renderPage = () =>\n        originalRenderPage({\n          enhanceApp: (App) => (props) =>\n            sheet.collectStyles(<App {...props} />),\n        });\n\n      const initialProps = await Document.getInitialProps(ctx);\n      \n      return {\n        ...initialProps,\n        styles: [\n          initialProps.styles,\n          sheet.getStyleElement(),\n        ],\n      };\n    } finally {\n      sheet.seal();\n    }\n  }\n\n  render() {\n    return (\n      <Html lang=\"en\">\n        <Head>\n          <meta charSet=\"utf-8\" />\n          <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n          <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossOrigin=\"anonymous\" />\n          <link href=\"https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap\" rel=\"stylesheet\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n\nexport default MyDocument;\n```\n\nKey benefits of Next.js with TypeScript for SSR:\n\n1. **Type-safe data fetching**: Strongly-typed props from getStaticProps and getServerSideProps\n2. **API route typing**: Type-safe request and response handling\n3. **Path parameters**: Type checking for dynamic route parameters\n4. **Component props**: Type validation for page components\n5. **Built-in type definitions**: Next.js provides comprehensive TypeScript definitions\n6. **SEO benefits**: Better server-rendered content with proper typings for metadata\n7. **Performance optimization**: Typed configuration for caching and revalidation strategies",
    "domain": "web_development"
  }
]
